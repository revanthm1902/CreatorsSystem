import { create } from 'zustand';
import { supabase } from '../lib/supabase';
import type { Profile, ActivityLogInsert } from '../types/database';

// Helper function to log activity
async function logActivity(activity: ActivityLogInsert) {
  try {
    await supabase.from('activity_log').insert(activity);
  } catch (err) {
    console.error('Failed to log activity:', err);
  }
}

interface UserState {
  users: Profile[];
  leaderboard: Profile[];
  loading: boolean;
  initialized: boolean;
  lastFetch: number;
  fetchUsers: (force?: boolean) => Promise<void>;
  fetchLeaderboard: (force?: boolean) => Promise<void>;
  createUser: (email: string, password: string, fullName: string, role: 'Admin' | 'User', actorId: string, actorName: string) => Promise<{ error: string | null; employeeId?: string }>;
  deleteUser: (userId: string) => Promise<{ error: string | null }>;
  reset: () => void;
}

const CACHE_DURATION = 30000; // 30 seconds

export const useUserStore = create<UserState>((set, get) => ({
  users: [],
  leaderboard: [],
  loading: false,
  initialized: false,
  lastFetch: 0,

  fetchUsers: async (force = false) => {
    const state = get();
    const now = Date.now();
    
    // Skip if already loading
    if (state.loading) return;
    
    // Use cache if valid and not forcing refresh
    if (!force && state.initialized && (now - state.lastFetch) < CACHE_DURATION) {
      return;
    }
    
    set({ loading: true });
    
    try {
      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .order('employee_id', { ascending: true });
      
      if (!error && data) {
        set({ users: data, initialized: true, lastFetch: now });
      }
    } catch (err) {
      console.error('Failed to fetch users:', err);
    } finally {
      set({ loading: false });
    }
  },

  fetchLeaderboard: async (force = false) => {
    const state = get();
    const now = Date.now();
    
    // Use cache if valid and not forcing refresh
    if (!force && state.leaderboard.length > 0 && (now - state.lastFetch) < CACHE_DURATION) {
      return;
    }
    
    try {
      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('role', 'User')
        .order('total_tokens', { ascending: false })
        .limit(50);
      
      if (!error && data) {
        set({ leaderboard: data });
      }
    } catch (err) {
      console.error('Failed to fetch leaderboard:', err);
    }
  },

  createUser: async (email: string, password: string, fullName: string, role: 'Admin' | 'User', actorId: string, actorName: string) => {
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          full_name: fullName,
          role,
        },
      },
    });

    if (authError) {
      return { error: authError.message };
    }

    if (!authData.user) {
      return { error: 'Failed to create user' };
    }

    // Create profile - employee_id is auto-generated by database trigger
    const { data: profileData, error: profileError } = await supabase
      .from('profiles')
      .insert({
        id: authData.user.id,
        full_name: fullName,
        role,
        total_tokens: 0,
        is_temporary_password: true,
      })
      .select('employee_id')
      .single();

    if (profileError) {
      return { error: profileError.message };
    }

    // Log activity
    await logActivity({
      actor_id: actorId,
      action_type: 'user_added',
      target_user_id: authData.user.id,
      task_id: null,
      message: `${actorName} added ${fullName} as ${role}`,
    });

    // Force refresh users list
    await get().fetchUsers(true);
    return { error: null, employeeId: profileData?.employee_id };
  },

  deleteUser: async (userId: string) => {
    const { error } = await supabase
      .from('profiles')
      .delete()
      .eq('id', userId);

    if (error) {
      return { error: error.message };
    }

    // Optimistically update local state
    set((state) => ({
      users: state.users.filter((u) => u.id !== userId),
    }));

    return { error: null };
  },

  reset: () => {
    set({ users: [], leaderboard: [], loading: false, initialized: false, lastFetch: 0 });
  },
}));
